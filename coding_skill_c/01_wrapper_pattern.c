/*
 * ============================================================================
 * íŒŒì¼ëª…: 01_wrapper_pattern.c
 * ê¸°ëŠ¥: Cì–¸ì–´ Wrapper(ë˜í¼) íŒ¨í„´ êµ¬í˜„ ì˜ˆì œ
 * 
 * ============================================================================
 * 1ï¸âƒ£ Wrapper(ë˜í¼) íŒ¨í„´ì´ë€?
 * ============================================================================
 * 
 * ê¸°ì¡´ í•¨ìˆ˜, ë¼ì´ë¸ŒëŸ¬ë¦¬, í•˜ë“œì›¨ì–´ ì ‘ê·¼ ì½”ë“œë¥¼ í•œ ê²¹ ê°ì‹¸ì„œ
 * ì‚¬ìš©ìëŠ” 'ë‹¨ìˆœí•œ ì¸í„°í˜ì´ìŠ¤'ë§Œ ì“°ê²Œ ë§Œë“œëŠ” ì„¤ê³„ íŒ¨í„´
 * 
 * êµ¬ì¡°:
 *   [ì‚¬ìš©ì ì½”ë“œ]
 *        â†“
 *   [Wrapper í•¨ìˆ˜]   â† ì¶”ìƒí™” ê³„ì¸µ
 *        â†“
 *   [HAL / Driver / Library / HW]
 * 
 * ============================================================================
 * 2ï¸âƒ£ ì™œ Cì—ì„œ Wrapper íŒ¨í„´ì„ ì“°ë‚˜?
 * ============================================================================
 * 
 * CëŠ” ê°ì²´ì§€í–¥ì´ ì—†ê¸° ë•Œë¬¸ì—, ì§ì ‘ ì ‘ê·¼í•˜ë©´ ìœ ì§€ë³´ìˆ˜ê°€ ì§€ì˜¥ì´ ë©ë‹ˆë‹¤.
 * 
 * Wrapperë¥¼ ì“°ëŠ” ì´ìœ :
 *   âœ… í•˜ë“œì›¨ì–´ ë³€ê²½ ëŒ€ë¹„ (MCU êµì²´)
 *   âœ… HAL / ë“œë¼ì´ë²„ êµì²´ ëŒ€ë¹„
 *   âœ… í…ŒìŠ¤íŠ¸ / Mock ê°€ëŠ¥
 *   âœ… ì˜ì¡´ì„± ë¶„ë¦¬ (ê²°í•©ë„ ê°ì†Œ)
 *   âœ… ì¸í„°í˜ì´ìŠ¤ ê³ ì •
 * 
 * ğŸ‘‰ íŠ¹íˆ ì„ë² ë””ë“œ + FW ê°œë°œ ì‹œ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤.
 * 
 * ============================================================================
 * 3ï¸âƒ£ ê°€ì¥ ê¸°ë³¸ì ì¸ Wrapper ì˜ˆì œ
 * ============================================================================
 * 
 * âŒ ë‚˜ìœ ì˜ˆ (ì§ì ‘ HAL í˜¸ì¶œ):
 *    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
 *    
 *    ë¬¸ì œì :
 *    - HAL ë³€ê²½ë˜ë©´ ì „ë¶€ ìˆ˜ì •
 *    - í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥
 *    - ì˜ë¯¸ê°€ ì½”ë“œì— ë“œëŸ¬ë‚˜ì§€ ì•ŠìŒ
 * 
 * âœ… Wrapper ì ìš©:
 * 
 *    (1) wrapper.h
 *        void LED_On(void);
 *        void LED_Off(void);
 * 
 *    (2) wrapper.c
 *        void LED_On(void) {
 *            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
 *        }
 * 
 *    (3) ì‚¬ìš©ì ì½”ë“œ
 *        LED_On();  // ğŸ“Œ ì‚¬ìš©ìëŠ” GPIOë„, HALë„ ëª¨ë¦„
 * 
 * ============================================================================
 * 4ï¸âƒ£ Wrapperì˜ í•µì‹¬ ê°€ì¹˜ (ì¤‘ìš”)
 * ============================================================================
 * 
 * â— WrapperëŠ” "ê¸°ëŠ¥"ì´ ì•„ë‹ˆë¼ "ê²½ê³„"ë‹¤
 * 
 * êµ¬ë¶„        | ì—­í• 
 * ------------|----------------------------------
 * App         | "ë¬´ì—‡ì„ í• ì§€" (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
 * Wrapper     | "ì–´ë–»ê²Œ ì ‘ê·¼í• ì§€" (ì¸í„°í˜ì´ìŠ¤)
 * Driver/HAL  | "ì‹¤ì œ ë™ì‘" (í•˜ë“œì›¨ì–´ ì œì–´)
 * 
 * ============================================================================
 * 5ï¸âƒ£ MCU / í†µì‹  ë³€ê²½ì— ê°•í•œ Wrapper êµ¬ì¡°
 * ============================================================================
 * 
 * UART â†’ CAN ë³€ê²½ ì˜ˆ:
 * 
 *    wrapper ì¸í„°í˜ì´ìŠ¤:
 *        void FOTA_Receive(uint8_t *buf, uint32_t len);
 * 
 *    UART ê¸°ë°˜ êµ¬í˜„:
 *        void FOTA_Receive(uint8_t *buf, uint32_t len) {
 *            HAL_UART_Receive(&huart1, buf, len, HAL_MAX_DELAY);
 *        }
 * 
 *    CAN ê¸°ë°˜ êµ¬í˜„ (ë‚˜ì¤‘ì— êµì²´):
 *        void FOTA_Receive(uint8_t *buf, uint32_t len) {
 *            CAN_Receive(buf, len);
 *        }
 * 
 *    ğŸ“Œ ìƒìœ„ ë¡œì§ì€ ë‹¨ í•œ ì¤„ë„ ìˆ˜ì • ì•ˆ í•¨
 * 
 * ============================================================================
 * 6ï¸âƒ£ êµ¬ì¡°ì²´ + í•¨ìˆ˜ í¬ì¸í„° Wrapper (ê³ ê¸‰)
 * ============================================================================
 * 
 * ğŸ‘‰ HAL ì¶”ìƒí™”ì—ì„œ ê°€ì¥ ë§ì´ ì“°ëŠ” íŒ¨í„´
 * 
 * ì •ì˜:
 *    typedef struct {
 *        int (*read)(uint8_t *buf, uint32_t len);
 *        int (*write)(uint8_t *buf, uint32_t len);
 *    } CommOps;
 * 
 * UART êµ¬í˜„:
 *    int uart_read(uint8_t *buf, uint32_t len) {
 *        return HAL_UART_Receive(&huart1, buf, len, 1000);
 *    }
 * 
 *    CommOps comm = {
 *        .read = uart_read,
 *        .write = uart_write
 *    };
 * 
 * ì‚¬ìš©:
 *    comm.read(rx_buf, 128);
 * 
 * ğŸ“Œ ì´ê±´ Cì—ì„œ ê°ì²´ì§€í–¥ í‰ë‚´ ë‚´ëŠ” í•µì‹¬ ê¸°ë²•
 * 
 * ============================================================================
 * 7ï¸âƒ£ Wrapper vs Adapter ì°¨ì´
 * ============================================================================
 * 
 * êµ¬ë¶„            | Wrapper              | Adapter
 * ----------------|----------------------|------------------------
 * ëª©ì             | ìˆ¨ê¹€, ë‹¨ìˆœí™”         | ì¸í„°í˜ì´ìŠ¤ ë³€í™˜
 * ê¸°ì¡´ API ë³€ê²½   | âŒ                   | âŒ
 * ì¸í„°í˜ì´ìŠ¤      | ìƒˆë¡œ ì •ì˜            | ê¸°ì¡´ ë§ì¶¤
 * ì„ë² ë””ë“œ        | ë§¤ìš° í”í•¨            | ë“œë¼ì´ë²„ í†µí•© ì‹œ ì‚¬ìš©
 * 
 * ============================================================================
 * 8ï¸âƒ£ ì„ë² ë””ë“œì—ì„œ Wrapper ì„¤ê³„ ì‹œ ì£¼ì˜ì 
 * ============================================================================
 * 
 * âŒ í”¼í•´ì•¼ í•  ê²ƒ:
 *    - Wrapper ì•ˆì—ì„œ ë¡œì§ ë¹„ëŒ€í™”
 *    - ìƒíƒœ ê´€ë¦¬ê¹Œì§€ ë„£ì–´ë²„ë¦¼
 *    - HAL í•¨ìˆ˜ ê·¸ëŒ€ë¡œ ë…¸ì¶œ
 * 
 * âœ… í•´ì•¼ í•  ê²ƒ:
 *    - WrapperëŠ” ì–‡ì•„ì•¼ í•œë‹¤
 *    - ì •ì±…ì€ App ê³„ì¸µ
 *    - HW ì˜ì¡´ì„±ì€ Wrapperê¹Œì§€ë§Œ
 * 
 * ============================================================================
 * 9ï¸âƒ£ ì§€ê¸ˆ ìƒí™©ì— ë”± ë§ëŠ” ì ìš© ì˜ˆ
 * ============================================================================
 * 
 * ì„ë² ë””ë“œ FW ê°œë°œì—ì„œ ìì£¼ ë‹¤ë£¨ëŠ” ê²ƒë“¤ì— Wrapper ì ìš©:
 * 
 *   - FOTA í†µì‹  (UART â†” CAN)
 *   - Flash Write / Erase
 *   - Motor Driver
 *   - Sensor Read
 *   - RTOS Delay / Time
 * 
 * ============================================================================
 * ğŸ”š í•œ ì¤„ ìš”ì•½
 * ============================================================================
 * 
 * C ì–¸ì–´ Wrapper íŒ¨í„´ì€
 * "ë³€í•  ìˆ˜ ìˆëŠ” ê²ƒì„, í•œ ê³³ì— ê°€ë‘ëŠ” ê¸°ìˆ "ì´ë‹¤.
 * 
 * ============================================================================
 * ì´ ì˜ˆì œ íŒŒì¼ì˜ êµ¬ì¡°
 * ============================================================================
 * 1. ë¡œê¹… ìœ í‹¸ë¦¬í‹°
 * 2. Wrapper í•¨ìˆ˜ë“¤ - íŒŒì¼ I/O (fopen, fclose)
 * 3. Wrapper í•¨ìˆ˜ë“¤ - ë©”ëª¨ë¦¬ ê´€ë¦¬ (malloc, free)
 * 4. ì‚¬ìš© ì˜ˆì œ (main)
 * 5. ì‹¤í–‰ ê²°ê³¼ í™•ì¸
 * ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* ============================================================================
 * ë¡œê¹… ìœ í‹¸ë¦¬í‹°
 * ============================================================================ */

// ë¡œê·¸ ë ˆë²¨ ì •ì˜
typedef enum {
    LOG_INFO,
    LOG_WARNING,
    LOG_ERROR
} LogLevel;

// ë¡œê·¸ ì¶œë ¥ í•¨ìˆ˜
void log_message(LogLevel level, const char* function_name, const char* message) {
    const char* level_str[] = {"INFO", "WARNING", "ERROR"};
    time_t now = time(NULL);
    char* time_str = ctime(&now);
    time_str[strlen(time_str) - 1] = '\0';  // ê°œí–‰ ì œê±°
    
    printf("[%s] [%s] %s: %s\n", time_str, level_str[level], function_name, message);
}

/* ============================================================================
 * ì›ë³¸ í•¨ìˆ˜ë“¤ (í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ë“¤ - ì´ë¯¸ ì¡´ì¬)
 * ì—¬ê¸°ì„œëŠ” FILE*, malloc, free ë“±ì˜ í‘œì¤€ í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©
 * ============================================================================ */

/* ============================================================================
 * Wrapper í•¨ìˆ˜ë“¤ - ë¡œê¹… ê¸°ëŠ¥ì´ ì¶”ê°€ëœ ë˜í¼
 * ============================================================================ */

// fopenì˜ wrapper - íŒŒì¼ ì—´ê¸° ì‘ì—…ì— ë¡œê¹… ì¶”ê°€
FILE* wrapped_fopen(const char* filename, const char* mode) {
    char log_msg[256];
    snprintf(log_msg, sizeof(log_msg), "íŒŒì¼ ì—´ê¸° ì‹œë„: %s (ëª¨ë“œ: %s)", filename, mode);
    log_message(LOG_INFO, "wrapped_fopen", log_msg);
    
    FILE* file = fopen(filename, mode);
    
    if (file == NULL) {
        snprintf(log_msg, sizeof(log_msg), "íŒŒì¼ ì—´ê¸° ì‹¤íŒ¨: %s", filename);
        log_message(LOG_ERROR, "wrapped_fopen", log_msg);
    } else {
        snprintf(log_msg, sizeof(log_msg), "íŒŒì¼ ì—´ê¸° ì„±ê³µ: %s", filename);
        log_message(LOG_INFO, "wrapped_fopen", log_msg);
    }
    
    return file;
}

// fcloseì˜ wrapper - íŒŒì¼ ë‹«ê¸° ì‘ì—…ì— ë¡œê¹… ì¶”ê°€
int wrapped_fclose(FILE* file, const char* filename) {
    char log_msg[256];
    snprintf(log_msg, sizeof(log_msg), "íŒŒì¼ ë‹«ê¸° ì‹œë„: %s", filename);
    log_message(LOG_INFO, "wrapped_fclose", log_msg);
    
    int result = fclose(file);
    
    if (result != 0) {
        snprintf(log_msg, sizeof(log_msg), "íŒŒì¼ ë‹«ê¸° ì‹¤íŒ¨: %s", filename);
        log_message(LOG_ERROR, "wrapped_fclose", log_msg);
    } else {
        snprintf(log_msg, sizeof(log_msg), "íŒŒì¼ ë‹«ê¸° ì„±ê³µ: %s", filename);
        log_message(LOG_INFO, "wrapped_fclose", log_msg);
    }
    
    return result;
}

// mallocì˜ wrapper - ë©”ëª¨ë¦¬ í• ë‹¹ì— ë¡œê¹… ë° NULL ì²´í¬ ì¶”ê°€
void* wrapped_malloc(size_t size, const char* caller) {
    char log_msg[256];
    snprintf(log_msg, sizeof(log_msg), "ë©”ëª¨ë¦¬ í• ë‹¹ ìš”ì²­: %zu bytes (í˜¸ì¶œì: %s)", size, caller);
    log_message(LOG_INFO, "wrapped_malloc", log_msg);
    
    void* ptr = malloc(size);
    
    if (ptr == NULL) {
        snprintf(log_msg, sizeof(log_msg), "ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨: %zu bytes", size);
        log_message(LOG_ERROR, "wrapped_malloc", log_msg);
    } else {
        snprintf(log_msg, sizeof(log_msg), "ë©”ëª¨ë¦¬ í• ë‹¹ ì„±ê³µ: %zu bytes (ì£¼ì†Œ: %p)", size, ptr);
        log_message(LOG_INFO, "wrapped_malloc", log_msg);
    }
    
    return ptr;
}

// freeì˜ wrapper - ë©”ëª¨ë¦¬ í•´ì œì— ë¡œê¹… ì¶”ê°€
void wrapped_free(void* ptr, const char* caller) {
    char log_msg[256];
    
    if (ptr == NULL) {
        snprintf(log_msg, sizeof(log_msg), "NULL í¬ì¸í„° í•´ì œ ì‹œë„ (í˜¸ì¶œì: %s)", caller);
        log_message(LOG_WARNING, "wrapped_free", log_msg);
        return;
    }
    
    snprintf(log_msg, sizeof(log_msg), "ë©”ëª¨ë¦¬ í•´ì œ: ì£¼ì†Œ %p (í˜¸ì¶œì: %s)", ptr, caller);
    log_message(LOG_INFO, "wrapped_free", log_msg);
    
    free(ptr);
}

/* ============================================================================
 * ì‚¬ìš© ì˜ˆì œ
 * ============================================================================ */

int main(void) {
    printf("========================================\n");
    printf("Wrapper íŒ¨í„´ ì˜ˆì œ\n");
    printf("========================================\n\n");
    
    // 1. íŒŒì¼ I/O wrapper ì‚¬ìš© ì˜ˆì œ
    printf("=== íŒŒì¼ I/O Wrapper ì˜ˆì œ ===\n");
    const char* filename = "test_wrapper.txt";
    
    // íŒŒì¼ ì“°ê¸°
    FILE* file = wrapped_fopen(filename, "w");
    if (file != NULL) {
        fprintf(file, "Wrapper íŒ¨í„´ í…ŒìŠ¤íŠ¸ ë°ì´í„°\n");
        fprintf(file, "ë¡œê¹… ê¸°ëŠ¥ì´ ì¶”ê°€ëœ íŒŒì¼ I/O\n");
        wrapped_fclose(file, filename);
    }
    printf("file: %p\n", file);

    printf("\n");
    
    // íŒŒì¼ ì½ê¸°
    file = wrapped_fopen(filename, "r");
    if (file != NULL) {
        char buffer[256];
        while (fgets(buffer, sizeof(buffer), file) != NULL) {
            printf("ì½ì€ ë°ì´í„°: %s", buffer);
        }
        wrapped_fclose(file, filename);
    }
    
    printf("\n");
    
    // ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íŒŒì¼ ì—´ê¸° ì‹œë„ (ì—ëŸ¬ ë¡œê¹… í…ŒìŠ¤íŠ¸)
    file = wrapped_fopen("nonexistent_file.txt", "r");
    
    printf("\n=== ë©”ëª¨ë¦¬ ê´€ë¦¬ Wrapper ì˜ˆì œ ===\n");
    
    // ë©”ëª¨ë¦¬ í• ë‹¹ ë° í•´ì œ
    int* numbers = (int*)wrapped_malloc(sizeof(int) * 10, "main");
    if (numbers != NULL) {
        // ë°ì´í„° ì‚¬ìš©
        for (int i = 0; i < 10; i++) {
            numbers[i] = i * 10;
        }
        printf("í• ë‹¹ëœ ë©”ëª¨ë¦¬ ì‚¬ìš© ì™„ë£Œ\n");
        
        // ë©”ëª¨ë¦¬ í•´ì œ
        wrapped_free(numbers, "main");
    }
    
    printf("\n");
    
    // NULL í¬ì¸í„° í•´ì œ ì‹œë„ (ê²½ê³  ë¡œê¹… í…ŒìŠ¤íŠ¸)
    wrapped_free(NULL, "main");
    
    printf("\n========================================\n");
    printf("Wrapper íŒ¨í„´ ì˜ˆì œ ì¢…ë£Œ\n");
    printf("========================================\n");
    
    return 0;
}

/*
 * ============================================================================
 * Wrapper íŒ¨í„´ì˜ ì¥ì  ì´ì •ë¦¬
 * ============================================================================
 * 
 * 1. ì›ë³¸ í•¨ìˆ˜ë¥¼ ìˆ˜ì •í•˜ì§€ ì•Šê³  ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥
 * 2. ë¡œê¹…, ë””ë²„ê¹…, ëª¨ë‹ˆí„°ë§ ê¸°ëŠ¥ì„ ì‰½ê²Œ ì¶”ê°€
 * 3. ì—ëŸ¬ ì²˜ë¦¬ë¥¼ ì¤‘ì•™í™”í•  ìˆ˜ ìˆìŒ
 * 4. ì½”ë“œ ì¬ì‚¬ìš©ì„± í–¥ìƒ
 * 5. í•˜ë“œì›¨ì–´ ë³€ê²½ì— ê°•í•œ êµ¬ì¡°
 * 6. í…ŒìŠ¤íŠ¸ ë° Mock ì‘ì„± ìš©ì´
 * 
 * ============================================================================
 * ì„ë² ë””ë“œ FW ê°œë°œì—ì„œ Wrapper íŒ¨í„´ì˜ ì‹¤ì „ í™œìš©
 * ============================================================================
 * 
 * 1. HAL(Hardware Abstraction Layer) ë˜í•‘
 *    - STM32 HAL â†’ Custom HAL
 *    - GPIO, UART, SPI, I2C ë“± í†µì¼ëœ ì¸í„°í˜ì´ìŠ¤ ì œê³µ
 * 
 * 2. RTOS í•¨ìˆ˜ ë˜í•‘
 *    - osDelay() â†’ Delay_ms()
 *    - FreeRTOS â†’ ë‹¤ë¥¸ RTOSë¡œ êµì²´ ì‹œ ìƒìœ„ ì½”ë“œ ë³€ê²½ ì—†ìŒ
 * 
 * 3. í†µì‹  í”„ë¡œí† ì½œ ë˜í•‘
 *    - FOTA_Receive() ë‚´ë¶€ì—ì„œ UART/CAN/USB êµì²´ ê°€ëŠ¥
 *    - ìƒìœ„ ë¡œì§ì€ í†µì‹  ë°©ì‹ ë³€ê²½ì— ì˜í–¥ ë°›ì§€ ì•ŠìŒ
 * 
 * 4. Flash ë©”ëª¨ë¦¬ ë˜í•‘
 *    - Flash_Write() / Flash_Erase()
 *    - ë‚´ë¶€ Flash â†” ì™¸ë¶€ Flash êµì²´ ìš©ì´
 * 
 * 5. ì„¼ì„œ/ì•¡ì¶”ì—ì´í„° ë˜í•‘
 *    - Motor_SetSpeed()
 *    - Sensor_ReadTemperature()
 *    - í•˜ë“œì›¨ì–´ êµì²´ ì‹œ Wrapperë§Œ ìˆ˜ì •
 * 
 * ============================================================================
 * ë©´ì ‘ / ê¸°ìˆ  ë©´ë‹´ ëŒ€ì‘ í¬ì¸íŠ¸
 * ============================================================================
 * 
 * Q: Wrapper íŒ¨í„´ì„ ì‚¬ìš©í•œ ê²½í—˜ì´ ìˆë‚˜ìš”?
 * A: "ë„¤, FOTA ì—…ë°ì´íŠ¸ ê¸°ëŠ¥ êµ¬í˜„ ì‹œ í†µì‹  ì¸í„°í˜ì´ìŠ¤ë¥¼ Wrapperë¡œ ì¶”ìƒí™”í–ˆìŠµë‹ˆë‹¤.
 *     ì´ˆê¸°ì—ëŠ” UARTë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ, Wrapper ë•ë¶„ì— CAN í†µì‹ ìœ¼ë¡œ ë³€ê²½í•  ë•Œ
 *     ìƒìœ„ FOTA ë¡œì§ì€ ë‹¨ í•œ ì¤„ë„ ìˆ˜ì •í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
 * 
 * Q: Wrapperì™€ Adapterì˜ ì°¨ì´ëŠ”?
 * A: "WrapperëŠ” ê¸°ì¡´ ê¸°ëŠ¥ì„ 'ìˆ¨ê¸°ê³  ë‹¨ìˆœí™”'í•˜ëŠ” ê²ƒì´ ëª©ì ì´ê³ ,
 *     AdapterëŠ” 'í˜¸í™˜ë˜ì§€ ì•ŠëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ì—°ê²°'í•˜ëŠ” ê²ƒì´ ëª©ì ì…ë‹ˆë‹¤.
 *     ì„ë² ë””ë“œì—ì„œëŠ” Wrapperë¥¼ ë” ë§ì´ ì‚¬ìš©í•©ë‹ˆë‹¤."
 * 
 * Q: Wrapper ì„¤ê³„ ì‹œ ì£¼ì˜í•  ì ì€?
 * A: "WrapperëŠ” ì–‡ê²Œ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤. ë¡œì§ì´ ë¹„ëŒ€í•´ì§€ë©´ Wrapperì˜ ì˜ë¯¸ê°€
 *     ì‚¬ë¼ì§€ê³  ìœ ì§€ë³´ìˆ˜ê°€ ì–´ë ¤ì›Œì§‘ë‹ˆë‹¤. ì •ì±…ì€ App ê³„ì¸µì— ë‘ê³ ,
 *     WrapperëŠ” ìˆœìˆ˜í•˜ê²Œ ì¸í„°í˜ì´ìŠ¤ ì—­í• ë§Œ í•´ì•¼ í•©ë‹ˆë‹¤."
 * 
 * ============================================================================
 * ë‹¤ìŒ í•™ìŠµ ë‹¨ê³„ ì¶”ì²œ
 * ============================================================================
 * 
 * 1. í•¨ìˆ˜ í¬ì¸í„° ê¸°ë°˜ Wrapper (ê³ ê¸‰)
 * 2. FOTA ì‹œìŠ¤í…œ ì „ì²´ Wrapper ì„¤ê³„
 * 3. STM32 HAL ì¶”ìƒí™” ê³„ì¸µ ì„¤ê³„
 * 4. FreeRTOS + Wrapper íŒ¨í„´ í†µí•©
 * 5. Unit Testë¥¼ ìœ„í•œ Mock Wrapper ì‘ì„±
 * 
 * ============================================================================
 */
